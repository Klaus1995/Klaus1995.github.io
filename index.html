<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Keep learning, keep running.">
<meta property="og:type" content="website">
<meta property="og:title" content="Klaus&#39; blog">
<meta property="og:url" content="http://www.klaus1995.com/index.html">
<meta property="og:site_name" content="Klaus&#39; blog">
<meta property="og:description" content="Keep learning, keep running.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Klaus&#39; blog">
<meta name="twitter:description" content="Keep learning, keep running.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.klaus1995.com/"/>





  <title>Klaus' blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6f1ec5fa4063dc5e7ee222caf0541902";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Klaus' blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.klaus1995.com/2017/05/02/简单理解Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Klaus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klaus' blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/02/简单理解Promise/" itemprop="url">简单理解Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-02T15:45:13+08:00">
                2017-05-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/02/简单理解Promise/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/02/简单理解Promise/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.klaus1995.com/2017/04/29/《JavaScript语言精粹》总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Klaus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klaus' blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/29/《JavaScript语言精粹》总结/" itemprop="url">《JavaScript语言精粹》总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-29T10:37:53+08:00">
                2017-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/29/《JavaScript语言精粹》总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/29/《JavaScript语言精粹》总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为最近没有在写什么项目，于是打算把《javascript语言精粹》看一遍，顺便写个总结笔记，本文只记载了我觉得可能要记下来的东西。</p>
<h1 id="第一章-精华"><a href="#第一章-精华" class="headerlink" title="第一章 精华"></a>第一章 精华</h1><h2 id="为什么要使用JavaScript"><a href="#为什么要使用JavaScript" class="headerlink" title="为什么要使用JavaScript"></a>为什么要使用JavaScript</h2><h2 id="分析JavaScript"><a href="#分析JavaScript" class="headerlink" title="分析JavaScript"></a>分析JavaScript</h2><h2 id="一个简单的试验场"><a href="#一个简单的试验场" class="headerlink" title="一个简单的试验场"></a>一个简单的试验场</h2><p>本书贯彻始终会使用一个method方法去定义新方法。</p>
<pre><code>Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};
</code></pre><h1 id="第二章-语法"><a href="#第二章-语法" class="headerlink" title="第二章 语法"></a>第二章 语法</h1><h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><p>建议使用<code>//</code>来注释，避免使用<code>/* */</code>，因为有的正则表达式可能会造成问题，例如：</p>
<pre><code>/* 
    var rm_a = /a*/.match(s);
*/
</code></pre><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>不允许用保留字来命名变量或者参数。</p>
<p><img src="《JavaScript语言精粹》总结/《JavaScript语言精粹》总结1.png" alt=""></p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>JavaScript只有一个数字类型，内部表示为64位浮点数。</p>
<p>NaN不等于任何值（包括它自己），可以用函数isNaN(number)检测。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串一旦被创建，就永远无法改变它，后续的修改只是创建了新的字符串而不是在其本身进行修改。</p>
<p>这也就是从前讲优化的时候有一个点是，对于字符串的相加操作建议用数组方法替代，就像这样：</p>
<pre><code>var mychar = &apos;a&apos; + &apos;b&apos; + &apos;c&apos;;

//建议替换为数组操作
var myArr = [];
myArr.push(&apos;a&apos;);
myArr.push(&apos;b&apos;);
myArr.push(&apos;c&apos;);
var myChar = myArr.join(&apos;&apos;);
</code></pre><p>不过好像是由于浏览器和引擎的内部优化，一般不会造成太大影响，所以现在基本不怎么提了，也不怎么用吧好像。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>可以通过条件语句（if和switch）、循环语句（while、for和do）、强制跳转语句（break、return和throw）和函数调用来改变执行序列。</p>
<p>for in语句会遍历对象的所有可枚举属性（包括继承的），所以如果只想要遍历属性自己的属性，可加一步判断。</p>
<pre><code>for (myVar in obj) {
    if (obj.hasOwnProperty(myVar)) {
        ...
    }
}
</code></pre><p>do和while的区别就是do至少会执行一次循环体里面的代码。</p>
<p>try catch语句会捕获try代码块中的异常，并自动跳转到catch代码块执行其中的代码。</p>
<p>throw语句就是认为抛出一个异常，如果throw语句在函数中，则函数调用被放弃。</p>
<p>break语句可以跳出循环，continue语句可以跳过循环体中后续代码，直接执行下次循环。</p>
<p>可以给循环加label，然后break label跳出特定循环，在复杂的循环中可能会用到。</p>
<p>各种运算的优先级：</p>
<p><img src="《JavaScript语言精粹》总结/《JavaScript语言精粹》总结2.png" alt=""></p>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h1 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h1><h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>对象字面量提供了一种非常方便地创建新对象值的表示法。</p>
<p>对象的属性名可以是包括空字符串在内的任意字符串，一般不用引号括住，但是如果是保留字或者非法的标识符（例如first-name是非法的，first_name就是合法的），就必须用引号括住。</p>
<p>对象可以嵌套。</p>
<h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p>获取对象的某个属性值，一般用 <code>.propertyName</code> 表示法，但是如果属性名不是合法的标识符，则需要用<code>[&#39;propertyName&#39;]</code>表示。</p>
<p>如果检索了对象的不存在的属性，返回<code>undefined</code>。</p>
<p>如果检索了<code>undefined</code>的某个属性，会抛出TypeError异常。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>给对象的某个属性赋值，如果对象存在这个属性，则覆盖属性原来的值，不存在的话，则创建属性并赋值。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>对象是引用类型值，只会被引用，不会被复制（除非用一些特定的方法函数）。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>想要具体了解原型可以看我关于原型的博客文章<a href="https://klaus1995.github.io/2017/03/06/JS%E5%8E%9F%E5%9E%8B/" target="_blank" rel="external">JS原型</a>。</p>
<p>然后推荐一本书<a href="https://book.douban.com/subject/26351021/" target="_blank" rel="external">你不知道的JavaScript（上卷）</a>，书中也对原型有了非常深刻的讲解，我觉得讲得非常好。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>for in语句可以遍历对象的所有可枚举属性，属性名出现的顺序是不确定的。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>delete运算符可以用来删除对象的属性。如果对象包含该属性，那么该属性就会被移除。它不会触及原型链中的任何对象。</p>
<h2 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h2><p>在没有必要的情况下应该尽量减少全局变量的使用。</p>
<h1 id="第四章-函数"><a href="#第四章-函数" class="headerlink" title="第四章 函数"></a>第四章 函数</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>函数就是对象。每个函数在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。</p>
<p>每个函数对象在创建时也随配有一个prototype属性。它的值时一个拥有constructor属性且值为该函数的对象。</p>
<h2 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h2><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>函数有4种调用模式：方法调用模式、函数调用模式、构造器调用模式和apply调用模式。这些模式在如何初始化关键参数this上存在差异。</p>
<h2 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h2><p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this绑定到该对象。</p>
<h2 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h2><p>当一个函数并非一个对象的属性时，那么它就是被当做一个属性来调用的。</p>
<p>以此模式调用函数时，this被绑定到全局对象。</p>
<h2 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h2><p>如果在一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那么新对象上。</p>
<p>一个函数，如果创建的目的就是希望结合new前缀来调用，那它就被称为构造器函数。按照约定，构造器函数的函数名为大写字母开头。</p>
<h2 id="Apply调用模式"><a href="#Apply调用模式" class="headerlink" title="Apply调用模式"></a>Apply调用模式</h2><p>apply方法让我们构建一个参数数组传递给调用函数。它也允许我们选择this的值。apply方法有两个参数，第一个是要绑定给this的值，第二个就是一个参数数组（不想用参数数组的可以用call方法）。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>当函数被调用时，会得到一个“免费”配送的参数，那就是arguments数组。函数可以通过此参数访问所有它被调用时传递给它的参数列表。</p>
<p>arguments并不是一个真正的数组，是一个类数组对象，拥有length属性，但是没有任何数组的方法。</p>
<h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><p>return语句可用来使函数提前返回。如果没有指定返回值，则返回undefined。</p>
<p>如果函数调用时在前面加上了new前缀，且返回值不是一个对象，则返回this（该新对象）。</p>
<p>##异常</p>
<p>throw语句中断函数的执行，并抛出一个异常（exception对象，通常包含一个name属性和一个message属性，当然也可添加其他属性）。</p>
<p>该异常可以被catch捕获。</p>
<h2 id="扩充类型的功能"><a href="#扩充类型的功能" class="headerlink" title="扩充类型的功能"></a>扩充类型的功能</h2><p>JavaScript允许给语言的基本类型扩充功能，通过给prototype添加方法，使该类型值都能使用该自定义方法。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数就是会直接或间接调用自身的一种函数。</p>
<p>请使用尾递归优化，详见阮一峰的《ES6入门》。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>JavaScript没有块状作用域，只有函数作用域。</p>
<p>ES6中新增了let和const可以定义块状作用域内的变量。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>作用域的好处就是内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments）。</p>
<p>函数嵌套函数，内部函数可以访问它被创建时所处的上下文环境，这被称为闭包。</p>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是一个利用函数和闭包构造的提供接口却隐藏状态与实现的函数或对象。</p>
<h2 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h2><p>如果设置函数方法返回值是this，就可以启用级联。就是函数的连续调用，类似于jQuery。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><h2 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h2><h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><p>&lt;–!未完待续–&gt;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.klaus1995.com/2017/04/27/关键渲染路径性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Klaus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klaus' blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/27/关键渲染路径性能优化/" itemprop="url">关键渲染路径性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T16:57:50+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web优化/" itemprop="url" rel="index">
                    <span itemprop="name">web优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/27/关键渲染路径性能优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/27/关键渲染路径性能优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是介绍了WEB关键渲染路径性能优化，是我在观看360奇舞团相关课程之后的一个总结，想要观看视频的请点击<a href="https://t.75team.com/video/play?id=65_260_2017032010370819aadb47-c79c-4d63-afd4-df0b42eaee48" target="_blank" rel="external">视频播放地址</a>。</p>
<h1 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h1><h2 id="基本渲染过程"><a href="#基本渲染过程" class="headerlink" title="基本渲染过程"></a>基本渲染过程</h2><p><img src="关键渲染路径性能优化/关键渲染路径性能优化1.png" alt=""></p>
<p>由图可以看出基本渲染过程，过程可以在Chrome开发者工具中的Timeline中进行查看。</p>
<ol>
<li>首先浏览器会解析HTML文档，生成相应的DOM树。</li>
<li>然后浏览器会解析文档的样式，生成CSSOM。</li>
<li>在以上两步中穿插着js的代码解析。</li>
<li>然后浏览器会结合解析完的DOM和CSSOM，生成一个RenderTree。</li>
<li>再然后，浏览器会根据生成的RenderTree进行相应的计算分给每个元素的空间大小以及相应的位置，进行Layout。</li>
<li>最后，会具体渲染每个元素的细节部分，也就是Paint。</li>
</ol>
<p><img src="关键渲染路径性能优化/关键渲染路径性能优化2.png" alt=""></p>
<p>这是我加载百度首页时截的部分图，可以简单看出渲染过程。</p>
<h2 id="Parse-HTML-to-DOM"><a href="#Parse-HTML-to-DOM" class="headerlink" title="Parse HTML to DOM"></a>Parse HTML to DOM</h2><p>这个过程就是将请求得到的HTML文档解析生成DOM树。</p>
<p>注意：</p>
<ul>
<li>浏览器的解析过程是<strong>增量构建</strong>的，即浏览器无需等待HTML加载完毕，便可开始解析DOM。</li>
</ul>
<h2 id="Parse-Stylesheet-to-CSSOM"><a href="#Parse-Stylesheet-to-CSSOM" class="headerlink" title="Parse Stylesheet to CSSOM"></a>Parse Stylesheet to CSSOM</h2><p>这个过程就是将的到的HTML中的style标签中的内容以及下载的css文件解析为CSSOM的过程，类似于生成DOM的过程。</p>
<p>注意：</p>
<ul>
<li>css选择器越详细，匹配速度越慢。</li>
</ul>
<h2 id="Recalculate-Style"><a href="#Recalculate-Style" class="headerlink" title="Recalculate Style"></a>Recalculate Style</h2><p>浏览器会将上两步得到的结果相结合，生成RenderTree。</p>
<p>注意：</p>
<ul>
<li>RenderTree包含了渲染页面所需要的节点。</li>
<li>无需渲染的节点不会被添加到RenderTree里，例如html和head节点，以及display:none的节点。</li>
<li>visibility:hidden的节点会被渲染，因为他虽然不可见，但是在页面中占有一定的位置。</li>
</ul>
<h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>这个过程就是浏览器计算渲染树节点的位置和大小。</p>
<p>注意：</p>
<ul>
<li>可以设置viewport来设置浏览器的理想窗口（一般应用在移动端）。通过在HTML中加入<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code>来设置理想窗口，如果不设置一般默认980px。</li>
<li>触发Layout的条件（不全）：</li>
</ul>
<ol>
<li>屏幕旋转</li>
<li>浏览器视窗的变化</li>
<li>与大小位置相关的CSS属性的变化</li>
</ol>
<h2 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h2><p>这个过程就是具体的填充过程，也就是渲染例如颜色等等样式。</p>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p>Layout和Paint是两个不同的过程，与之相关的就是我们经常说到的回流（reflow）与重绘（repaint），如果想要了解这方面具体的内容，可以看张鑫旭翻译的这篇文章<a href="http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="external">回流与重绘：CSS性能让JavaScript变慢？</a></p>
<p>另外，CSS也是增量构建的，但不是增量渲染的，它只会在所有样式都构建完成以后统一渲染（因为后面设置的样式会将前面设置的样式覆盖掉），然后生成RenderTree。</p>
<h1 id="资源对渲染的影响"><a href="#资源对渲染的影响" class="headerlink" title="资源对渲染的影响"></a>资源对渲染的影响</h1><h2 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h2><p>资源类型有很多，最常见的是：</p>
<ul>
<li>CSS</li>
<li>JS</li>
<li>font</li>
<li>img</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>首先，页面会在加载DOM和CSSOM之后开始初次渲染页面，而不是加载完DOM就立即开始渲染，这就造成了CSS 阻塞初次渲染的现象。</p>
<p>注意：</p>
<ul>
<li>通过<code>&lt;style&gt;/* styles here */&lt;/style&gt;</code>和<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;</code>定义的CSS，均会阻塞初次渲染。</li>
<li>浏览器会在解析CSS完成之后进行初次渲染，这是为了防止样式突变带来的抖动。</li>
<li>不管CSS出现在文档的哪个位置，都会阻塞整个文档的初次渲染。</li>
<li>通过link标签引入的CSS阻塞的时间可能更长，因为加载它需要一个网络来回时间。</li>
</ul>
<p>媒体查询：</p>
<ul>
<li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;index_print.css&quot; media=&quot;print&quot;&gt;</code></li>
<li>此样式表仍会加载</li>
<li>当浏览器环境不匹配媒体查询条件时，该样式表不会阻塞渲染</li>
<li>我们可以针对不同的媒体环境拆分CSS文件，并为link标签添加媒体查询，避免为了加载非关键CSS资源，而阻塞了初次渲染</li>
</ul>
<p>各种加载CSS的方法：</p>
<p><img src="关键渲染路径性能优化/关键渲染路径性能优化3.png" alt=""></p>
<p>但是请注意，虽然有的方法不会阻塞初次渲染，但是会在后来加载完CSS文件以后使页面产生一个巨大的抖动（渲染样式）。</p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p>在HTML中加载JS代码会阻塞初次渲染。</p>
<p>注意：</p>
<ul>
<li>通过<code>&lt;script&gt;&lt;/script&gt;</code>标签和外部引用JS文件均会阻塞HTML parser，因而会阻塞出现在脚本后面的HTML标记的渲染。</li>
<li>通过外部引入的JS文件阻塞的时间可能更长，因为加载它需要一个网络来回时间。</li>
<li>JS可以修改DOM，所以在加载JS代码的时候，浏览器会停止解析DOM的工作。</li>
</ul>
<p>同时，CSS也会阻塞JS。这是因为JavaScript可能会读取和修改CSSOM，因此要等到CSSOM构建完成之后，JS才会执行。</p>
<p>两个并列的外部引用的JS文件会同时进行加载（不是解析），这是因为JS虽然会阻塞HTML parser，停止DOM的构建工作，但是浏览器会去识别脚本后面的资源，并提前加载。</p>
<p>因此，可以通过把<code>&lt;script&gt;&lt;/script&gt;</code>标签放到文档最后，或者用defer和async属性来解决JS加载对HTML parser的阻塞。defer和async属性有差异，具体看下图：</p>
<p><img src="关键渲染路径性能优化/关键渲染路径性能优化4.png" alt=""></p>
<p>各种加载JS的方法：</p>
<p><img src="关键渲染路径性能优化/关键渲染路径性能优化5.png" alt=""></p>
<h2 id="font"><a href="#font" class="headerlink" title="font"></a>font</h2><p>在加载完HTML文档后，浏览器会等待字体文件加载完成后，才会显示具体内容（应用了该字体的元素）。</p>
<p>通过preload异步加载CSS字体文件，就不会阻塞初次渲染。</p>
<h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><p>图片文件并不会阻塞初次渲染。</p>
<h1 id="优化关键渲染路径"><a href="#优化关键渲染路径" class="headerlink" title="优化关键渲染路径"></a>优化关键渲染路径</h1><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p>将以下指标压缩到最低：</p>
<ul>
<li>关键资源数</li>
<li>关键资源体积</li>
<li>关键资源网络来回数</li>
</ul>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><ul>
<li>上面提到的为了防止阻塞的各种方法。</li>
<li>部分CSS和JS使用内联以减少关键资源数和关键资源网络来回（请勿盲目使用内联）。</li>
<li>http2主动推送所需要的资源（目前支持并不好）。</li>
<li>利用缓存和内联（第一次用内联优化，以后就利用缓存）。</li>
<li>各种类型的文件压缩。</li>
<li>服务器优化。</li>
<li>合理利用缓存，优化网络。</li>
</ul>
<p>如果哪里有错误的话请与我联系，我会及时更正，联系方式在右边个人介绍中，谢谢观看。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.klaus1995.com/2017/03/21/常用代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Klaus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klaus' blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/常用代码/" itemprop="url">常用代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T16:32:31+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/常用代码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/常用代码/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="兼容各浏览器的事件监听组件"><a href="#兼容各浏览器的事件监听组件" class="headerlink" title="兼容各浏览器的事件监听组件"></a>兼容各浏览器的事件监听组件</h1><pre><code>EventUtil={
    addListener:function(target,type,handler){
    if(target.addEventListener){
        target.addEventListener(type,handler);
    }else if(target.attachEvent){
        target.attach(&quot;on&quot;+type,function(){
              handler.call(target);  //让handler中的this指向目标元素
        });
    }else{
        target[&quot;on&quot;+type]=handler;
    }
    },
    removeListener:function(target,type,handler){   
      if(target.removeEventListener){    
        target.removeEventListener(type,handler);          
     }else if(target.detachEvent){
        target.detachEvent(&quot;on&quot;+type,handler);
     }else{
        target[&quot;on&quot;+type]=null;
     }
    },
    getEvent:function(e){      //获取事件对象
     var evt=window.event||e;
     return evt;
    },
    getTarget:function(e){      //获得目标对象
     var evt=EventUtil.getEvent(e);
     var target;
     if(evt.target){ target=evt.target;}
     else {target=evt.srcElement;}
     return target;
    },
    stopPropagation:function(e){  //停止冒泡
     var evt=EventUtil.getEvent(e);
     if(evt.stopPropagation) {evt.stopPropagation();}
     else {evt.cancelBubble=true;}
    },
    preventDefault:function(e){   //阻值默认行为的发生
     var evt=EventUtil.getEvent(e);
     if(evt.preventDefault){ evt.preventDefault(); }
     else {e.returnValue=false;}
    }
}
</code></pre><h1 id="Cookie组件"><a href="#Cookie组件" class="headerlink" title="Cookie组件"></a>Cookie组件</h1><pre><code>CookieUtil=｛
    addCookie:function(key,value,options){
        var str=key+&quot;=&quot;+escape(value);
        if(options.expires){
           var curr=new Date();   //options.expires的单位是小时
           curr.setTime(curr.getTime()+options.expires*3600*1000);
           options.expires=curr.toGMTString();
        }
        for(var k in options){   //有可能指定了cookie的path，cookie的domain
           str+=&quot;;&quot;+k+&quot;=&quot;+options[k];
        }
        document.cookie=str;
    },
    queryCookie:function(key){
      var cookies=document.cookie;
     //获得浏览器端存储的cookie,格式是key=value;key=value;key=value
      cookies+=&quot;;&quot;;
      var start=cookies.indexOf(key);
      if(start&lt;=-1){ return null; }  //说明不存在该cookie
      var end=cookies.indexOf(&quot;;&quot;,start);
      var value=cookies.slice(start+key.length+1,end);
      return unescape(value);
    },
    deleteCookie:function(key){
      var value=CookieUtil.queryCookie(key);
      if(value===null){return false;}
      CookieUtil.addCookie(key,value,{expires:0});//把过期时间设置为0，浏览器会马上自动帮我们删除cookie
    }
｝
</code></pre><h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><pre><code>var oldObject = {...};
var newObject = Object.assign({},oldObject); //浅拷贝，对象内嵌套的对象不会被拷贝
</code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><pre><code>var oldObject = {...};
function deepCopy (newObj, oldObj) {
    for (key in oldObj) {
        var prop = oldObj[key];
        if (typeof prop === &apos;object&apos;) {
            if (Object.prototype.toString.call(prop) === &apos;[object Array]&apos;){
                newObj[key] = newObj[key] || [];
                deepCopy(newObj[key],prop);
            }else{
                newObj[key] = newObj[key] || {};//如果新对象有定义属性则保留下来
                deepCopy(newObj[key],prop);//递归，向下拷贝
            }
        }else{
            newObj[key] = prop;
        }
    }
    return newObj;
}
var newObject = deepCopy({},oldObject);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.klaus1995.com/2017/03/08/JS继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Klaus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klaus' blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/08/JS继承/" itemprop="url">JS继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T22:00:28+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/08/JS继承/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/08/JS继承/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章继续讲js原型和继承，参考高程三第六章。</p>
<hr>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>先上一段代码（继承）：</p>
<pre><code>function SuperType(){
    this.property = &apos;super&apos;;
}

SuperType.prototype.getSuperValue = function(){
    return this.property;
}

function SubType(){
    this.subproperty = &apos;sub&apos;;
}

//继承了SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function(){
    return this.subproperty;
}

var instance = new SubType();
alert(instance.getSuperValue());  //super
alert(instance.getSubValue());  //sub

//检测实例对象的类型
alert(instance instanceof Object);  //true
alert(instance instanceof SuperType);  //true
alert(instance instanceof SubType);  //true
</code></pre><p>其中的<code>SubType.prototype = new SuperType();</code>可以这么理解：sub实例的爸爸（原型）= super的实例，所以sub实例的爷爷 = super实例的爸爸（原型），他们的继承关系就是<code>SuperType.prototype==&gt;SubType.prototype(new SuperType())==&gt;new SubType()</code>。</p>
<p>所以它们之间的指针关系如图：</p>
<p><img src="JS继承/JS继承1.png" alt=""></p>
<p><strong style="color: red">注意：</strong></p>
<ul>
<li>想要修改SubType的原型的话，要在<code>SubType.prototype = new SuperType();</code>语句之后写（之前写的话，这一条赋值语句会修改SubType.prototype的指针，相当于之前写的都没用了）。</li>
<li>修改SubType.prototype的时候不能用字面量定义，因为那样会重写SubType.prototype，也就相当于SubType和SuperType毫无关系了。</li>
<li>调用instance实例的属性或者方法的时候，首先先查找instance实例（SubType），然后向上查找SubType.prototype，然后继续向上查找SuperType.prototype和SuperType。</li>
</ul>
<p>而这种原型链构造新对象的方法也有其缺点：</p>
<ul>
<li>无法给SuperType构造函数传递参数</li>
<li>SuperType和SuperType.prototype的所有属性和方法都被SubType的实例共享，如果有一些私有属性或者说引用类型的值作为属性就很蛋疼了（引用类型值因为是指针调用，所以一个实例修改，所有实例都会被修改）</li>
</ul>
<p>为了解决这些问题，于是便有了借用构造函数模式。</p>
<hr>
<h1 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h1><p>这种技术的思路非常简单，就是在子类型的构造函数内调用了超类型的构造函数，代码如下：</p>
<pre><code>function SuperType(name){
    this.name = name;
}

function SubType(name,age){
    SuperType.call(this,name)
    this.age = age
}

var instance = new SubType(&apos;Klaus&apos;,22);
alert(instance.name);  //Klaus
alert(instance.age);  //22

//检测类型
alert(instance instanceof Object);  //true
alert(instance instanceof SuperType);  //false
alert(instance instanceof SubType);  //true
</code></pre><p>这种模式可以给超类型构造函数传递参数，超类型属性也全都是实例私有的，但是这种模式缺点也很明显：</p>
<ul>
<li>新建实例无法调用SuperType.prototype的属性和方法</li>
<li>因此，超类型中需要共享的方法必须放在超类型构造函数中而不能放在其原型中，所以函数的复用无从谈起</li>
<li>因为子类型和超类型没有继承关系，只是简单的调用，所以实例并不属于超类型的对象</li>
</ul>
<hr>
<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p>这种模式结合了原型链模式和借用构造函数模式的优点，代码如下：</p>
<pre><code>function SuperType(name){
    this.name = name;
    this.color = [&apos;red&apos;,&apos;green&apos;];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
}

function SubType(name,age){
    SuperType.call(this,name);
    this.age = age;
}

//SubType继承了SuperType
SubType.prototype = new SuperType();

SubType.prototype.sayAge = function(){
    alert(this.age);
}

var instance1 = new SubType(&apos;Klaus&apos;,22);
instance1.sayName();  //Klaus
instance1.sayAge();  //22
instance1.color.push(&apos;blue&apos;);
alert(instance1.color);  //red,green,blue

var instance2 = new SubType(&apos;nico&apos;,25);
instance2.sayName();  //nico
instance2.sayAge();  //25
alert(instance2.color);  //red,green

//检测实例对象的类型
alert(instance1 instanceof Object);  //true
alert(instance1 instanceof SuperType);  //true
alert(instance1 instanceof SubType);  //true
alert(Object.prototype.isPrototypeOf(instance1));  //true
alert(SuperType.prototype.isPrototypeOf(instance1));  //true
alert(SubType.prototype.isPrototypeOf(instance1));  //true
</code></pre><hr>
<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p>原型式继承方式是道格拉斯提出来的一种实现继承的方法，它的代码是这样的：</p>
<pre><code>function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
</code></pre><p>这一段代码的可以这么理解，把F看做上面所讲代码的子类型，o看做超类型，子类型继承了超类型，函数最后返回了F的实例。</p>
<p>有了这段代码，我们就可以不定义子类型的构造函数（其实在object函数中定义了，只不过执行完被垃圾回收了而已）就直接得到继承。</p>
<p>后来，这种原型式继承被ECMAScript规范化了，并定义成了<code>Object.create()</code>方法，这个方法接受两个参数，第一个是被继承的对象o（可以理解为超类型构建函数），第二个是新建对象的私有属性（可以理解为子类型的构建函数），第二个参数的格式类似于<code>Object.defineProperties()</code>方法需要传入的参数格式。</p>
<p>使用形式类似于<code>var sub = Object.create(super)</code>，但是别忘了继承的属性都是共享的。</p>
<hr>
<h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p>寄生式继承也是道格拉斯提出来了，代码如下：</p>
<pre><code>function createAnother(original){
    var clone = object(original);  //原型式继承创建对象
    clone.sayHi = function(){       //给新创建的对象添加私有属性和方法
        alert(&apos;Hi!&apos;);
    };
    return clone;
}
</code></pre><p>现在这种方法完全可以用<code>Object.defineProperties()</code>方法替代：</p>
<pre><code>var clone = Object.create(original,{
    sayHi : {
        value : function(){
            alert(&apos;Hi!&apos;);
        }
    }
})

clone.sayHi();  //hi!
</code></pre><p>这种方法和构造函数一样，会因为函数不能复用而使效率降低。</p>
<hr>
<h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p>前面介绍的组合继承模式是比较完美的，但是它仍然有一点不足，因为它会两次调用SuperType()，看代码：</p>
<pre><code>function SuperType(name){
    this.name = name;
    this.color = [&apos;red&apos;,&apos;green&apos;];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
}

function SubType(name,age){
    SuperType.call(this,name);  //第二次调用
    this.age = age;
}

//SubType继承了SuperType
SubType.prototype = new SuperType();  //第一次调用
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
    alert(this.age);
}
</code></pre><p>第一次调用会使子类型的原型带有超类型构造函数中定义的属性和方法，第二次调用会使子类型实例带有超类型构造函数中定义的属性和方法，这就造成了重复，两次定义了相同的属性，造成了浪费。</p>
<p>寄生组合式继承就完美解决了这个问题：</p>
<pre><code>function object(o){
    function F(){}
    F.prototype = o;  
    return new F(); 
}

function inheritPrototype(subType,superType){
    var prototype = object(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
}

function SuperType(name){
    this.name = name;
    this.color = [&apos;red&apos;,&apos;green&apos;];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
}

function SubType(name,age){
    SuperType.call(this,name);
    this.age = age;
}

//SubType继承了SuperType
inheritPrototype(SubType,SuperType);

SubType.prototype.sayAge = function(){
    alert(this.age);
}

var instance1 = new SubType(&apos;Klaus&apos;,22);
instance1.sayName();  //Klaus
instance1.sayAge();  //22
instance1.color.push(&apos;blue&apos;);
alert(instance1.color);  //red,green,blue

var instance2 = new SubType(&apos;nico&apos;,25);
instance2.sayName();  //nico
instance2.sayAge();  //25
alert(instance2.color);  //red,green

//检测实例对象的类型
alert(instance1 instanceof Object);  //true
alert(instance1 instanceof SuperType);  //true
alert(instance1 instanceof SubType);  //true
alert(Object.prototype.isPrototypeOf(instance1));  //true
alert(SuperType.prototype.isPrototypeOf(instance1));  //true
alert(SubType.prototype.isPrototypeOf(instance1));  //true

//检测子类型原型有没有继承超类型构造函数中的name和color属性
alert(instance1.hasOwnProperty(&apos;name&apos;));  //true
alert(SubType.prototype.hasOwnProperty(&apos;name&apos;));  //false
alert(instance1.hasOwnProperty(&apos;color&apos;));  //true
alert(SubType.prototype.hasOwnProperty(&apos;color&apos;));  //false
</code></pre><p>现在我们来理一下他们之间的关系：</p>
<ul>
<li>F的原型=o</li>
<li>object(o)返回F的实例，也就是object(o)=F的实例</li>
<li>prototype=object(superType.prototype)，也就是说prototype=F的实例，F的原型是superType.prototype</li>
<li>subType的原型=prototype</li>
</ul>
<p><strong style="color: red">把它们连接起来就是：</strong></p>
<ul>
<li>subType的原型 = prototype = object(superType.prototype) = F的实例</li>
<li>F的原型 = o = superType.prototype</li>
</ul>
<p><strong style="color: red">这两个个等式只要看开头和结尾就可以了。第一个等式显示要继承的子类型的原型为一个构造函数F（中间量）的实例，这样，子类型的原型就完美继承了F的构造函数和原型所有的属性和方法，和我们上面讲的原型链中的<code>SubType.prototype = new SuperType();</code>语句是一样的作用。</strong></p>
<p><strong style="color: red">下面的等式，F的原型是superType的原型，即超类型的原型，使F继承到了超类型原型里的方法和属性，而没有继承到超类型构造函数里的属性和方法。</strong></p>
<p>总结下来就是：subType的原型继承了F构造函数和原型中所有的属性和方法，F的原型继承了superType的原型而没有继承到superType的构造函数，而F的构造函数在object函数中被定义为没有任何的属性和方法。</p>
<p>废了这么大劲，与上面讲的组合继承有什么不同呢？</p>
<p>他们的最大不同就在于F这个中间量，因为有了这个中间量，使SubType的原型不需要继承SuperType的构造函数中的属性和方法，只继承到了SuperType原型中的属性和方法，所以解决了那个前面提到的“两次定义了相同的属性”的问题。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过这一系列的演变，最后得出的结论是，最好的继承方式就是寄生组合继承。</p>
<p>当然，从原型式继承被ECMAScript规范化了，并定义成了<code>Object.create()</code>方法后，寄生组合继承还可以被简写：</p>
<pre><code>function inheritPrototype(subType,superType){
    var prototype = Object.create(superType.prototype);  //用Object.create()方法替代了原来的objec()方法
    prototype.constructor = subType;
    subType.prototype = prototype;
}

function SuperType(name){
    this.name = name;
    this.color = [&apos;red&apos;,&apos;green&apos;];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
}

function SubType(name,age){
    SuperType.call(this,name);
    this.age = age;
}

//SubType继承了SuperType
inheritPrototype(SubType,SuperType);

SubType.prototype.sayAge = function(){
    alert(this.age);
}

var instance1 = new SubType(&apos;Klaus&apos;,22);
instance1.sayName();  //Klaus
instance1.sayAge();  //22
instance1.color.push(&apos;blue&apos;);
alert(instance1.color);  //red,green,blue

var instance2 = new SubType(&apos;nico&apos;,25);
instance2.sayName();  //nico
instance2.sayAge();  //25
alert(instance2.color);  //red,green

//检测实例对象的类型
alert(instance1 instanceof Object);  //true
alert(instance1 instanceof SuperType);  //true
alert(instance1 instanceof SubType);  //true
alert(Object.prototype.isPrototypeOf(instance1));  //true
alert(SuperType.prototype.isPrototypeOf(instance1));  //true
alert(SubType.prototype.isPrototypeOf(instance1));  //true

//如果需要重新追加新的共享方法和属性，可以向SuperType.prototype或者SubType.prototype追加，追加的属性方法可以被所有的子类型实例共享，非常方便
SuperType.prototype.sayHi = function(){
    alert(&apos;Hi!&apos;);  
}

instance1.sayHi();  //Hi!

//检测子类型原型有没有继承超类型构造函数中的name和color属性
alert(instance1.hasOwnProperty(&apos;name&apos;));  //true
alert(SubType.prototype.hasOwnProperty(&apos;name&apos;));  //false
alert(instance1.hasOwnProperty(&apos;color&apos;));  //true
alert(SubType.prototype.hasOwnProperty(&apos;color&apos;));  //false
</code></pre><p>这篇文章可能讲的不是太清楚，因为太复杂了，很难讲清楚，需要自己慢慢思考领悟，经过这么多绕来绕去的继承，最后肯定能领会到继承的真谛。</p>
<p>如果哪里有错误的话请与我联系，我会及时更正，联系方式在右边个人介绍中，谢谢观看。</p>
<hr>
<h1 id="2017-3-9补充"><a href="#2017-3-9补充" class="headerlink" title="2017.3.9补充"></a>2017.3.9补充</h1><p>在群里讨论了原型与继承的问题，有一个小伙伴画了一张图能够更好地理解原型链的结构，在这里贴上地址：<a href="https://www.processon.com/view/link/586c6f75e4b067ce853bb863" target="_blank" rel="external">https://www.processon.com/view/link/586c6f75e4b067ce853bb863</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.klaus1995.com/2017/03/07/关于编程思想的一点感悟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Klaus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klaus' blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/07/关于编程思想的一点感悟/" itemprop="url">关于编程思想的一点感悟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T13:12:27+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/07/关于编程思想的一点感悟/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/07/关于编程思想的一点感悟/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨晚在知乎看到了一篇文章，受益匪浅，决定总结一下。</p>
<p>文章地址<a href="https://zhuanlan.zhihu.com/p/25595871" target="_blank">为什么你的前端工作经验不值钱？</a></p>
<hr>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><blockquote>
<p>编写一个javscript函数 fn，该函数有一个参数 n（数字类型），其返回值是一个数组，该数组内是 n 个随机且不重复的整数，且整数取值范围是 [2, 32]。</p>
</blockquote>
<p>第一眼看起来好像是很简单，但是实际做起来就有很多坑。</p>
<hr>
<h1 id="可用"><a href="#可用" class="headerlink" title="可用"></a>可用</h1><blockquote>
<p>作为一段需要满足需求的代码来说，它最核心的、最低的要求：可用。</p>
</blockquote>
<pre><code>function fn(n){
    //准备一个容器
    var arr = new Array();
    //循环
    for(var i = 0 ; i &lt; n ; i ++){
        //生成随机数
        var num = getRand(2,32);
        //检测是否重复
        if(checkArr(arr,num)){
            i --;
        }else{
            arr.push(num);
        }
    }
    //返回数组
    return arr;


    //所需要自定义的方法

    //生成随机数
    function getRand(min,max){
        var num = Math.floor(Math.random()*(max-min+1)+2);
        return num;
    }

    //检测是否重复
    function checkArr(arr,num){
        if (arr.indexOf(num) === -1) {
            return false;
        }else{
            return true;
        };
    }
}
//测试
console.log(fn(5));
</code></pre><p>以上是我参照文章的思路写的一个demo，测试可行。</p>
<hr>
<h1 id="健壮"><a href="#健壮" class="headerlink" title="健壮"></a>健壮</h1><blockquote>
<p>所谓“健壮”，即最基本的兼容性处理、边界处理，异常处理、用户输入校验。很多时候，需求方不会明确告诉你这些逻辑怎么处理，但并不意味着你不需要处理。</p>
<p>健壮的程序，一定会将这些兼容性、边界、异常、输入做处理，以保证核心功能的正确输出。当然，如果你的代码没有任何输入并不考虑兼容性（可能吗？）或者仅仅是内部函数，那这一步要求可以降低，并不意味着你可以完全不做。</p>
<p>好，回过头看代码：</p>
<p>——如果你没有对 n 的取值范围做校验（n必须是 1 到 31 之间的整数），请将 经验系数 * 0.3；</p>
<p>——如果你没有对 n 是否为数字做校验，请将 经验系数 * 0.5；</p>
<p>——如果你没有对 n 是否存在做校验，请将 经验系数 * 0.7；</p>
<p>——如果上述校验都做了，但是没有校验对，请将 经验系数 * 0.9；你需要多练习，仔细认真的。</p>
</blockquote>
<p>文章在这里提出了三个坑，很可能产生bug。</p>
<p>个人认为，第一个坑，只要限制小于等于31且为整数就好，因为如果n小于1，最多返回一个空数组，而大于31则会导致数组中必然存在重复，最后导致无法跳出循环导致无响应。</p>
<p>而n是否为整数并不影响输出，例如 n = 23.231，只会返回一个23个数的数组，这可能与这个方法想要表达的不符，需要检测。</p>
<p>第二个坑，如果未检测n是否为数字，则可能传入乱七八糟的参数，与方法想要实现的功能不符，虽然能输出数组（因为只有一个关系操作符用到了n，js内置强制类型转换，如true会转化成1，‘5’字符串会转化成5，但是很有可能触发第一个坑的无限循环bug），需要检测。</p>
<p>第三个坑，是否对n的存在做校验。如果不传入参数n，n的值为undefined，在进行关系操作符时自动转化成0，输出一个空数组。但是与所要实现的功能不符，需要检测。</p>
<p>针对这三个坑，我对代码进行了改造。</p>
<pre><code>function fn(n){
    //检测n是否存在
    if(n||n===0){

    }else{
        console.log(&apos;请输入参数n&apos;);
        return;
    };
    //检测n是否为数值且为整数
    if(parseInt(n)!==n){
        console.log(&apos;请输入的n为数值且为整数&apos;);
        return;
    };
    //检测是n的取值范围
    if(n&lt;1||n&gt;31){
        console.log(&apos;请输入n的取值范围为[1,31]&apos;);
        return;
    };
    //准备一个容器
    var arr = new Array();
    //循环
    for(var i = 0 ; i &lt; n ; i ++){
        //生成随机数
        var num = getRand(2,32);
        //检测是否重复
        if(checkArr(arr,num)){
            i --;
        }else{
            arr.push(num);
        }
    }
    //返回数组
    return arr;

    //所需要自定义的方法

    //生成随机数
    function getRand(min,max){
        var num = Math.floor(Math.random()*(max-min+1)+2);
        return num;
    }

    //检测是否重复
    function checkArr(arr,num){
        if (arr.indexOf(num) === -1) {
            return false;
        }else{
            return true;
        };
    }
}
//测试
console.log(fn());
</code></pre><p>经过测试可用（鬼知道设计算法的时候踩了多少坑）。</p>
<hr>
<h1 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h1><blockquote>
<p>javascript没有强数据类型，函数的返回值也无法强制返回的数据格式。但是作为“可靠”的要求，尽可能在任何情况下，都返回一个可靠的结果，哪怕是异常情况下。</p>
</blockquote>
<p>于是修改代码，使其在错误的情况下也能返回一个空数组（我把控制台输出错误类型的功能保存了，如果不需要可以删掉相应代码），只需要对代码稍加改造。</p>
<pre><code>function fn(n){
    //检测n是否存在
    if(n||n===0){

    }else{
        console.log(&apos;请输入参数n&apos;);
        return [];
    };
    //检测n是否为数值且为整数
    if(parseInt(n)!==n){
        console.log(&apos;请输入的n为数值且为整数&apos;);
        return [];
    };
    //检测是n的取值范围
    if(n&lt;1||n&gt;31){
        console.log(&apos;请输入n的取值范围为[1,31]&apos;);
        return [];
    };
    //准备一个容器
    var arr = new Array();
    //循环
    for(var i = 0 ; i &lt; n ; i ++){
        //生成随机数
        var num = getRand(2,32);
        //检测是否重复
        if(checkArr(arr,num)){
            i --;
        }else{
            arr.push(num);
        }
    }
    //返回数组
    return arr;

    //所需要自定义的方法

    //生成随机数
    function getRand(min,max){
        var num = Math.floor(Math.random()*(max-min+1)+2);
        return num;
    }

    //检测是否重复
    function checkArr(arr,num){
        if (arr.indexOf(num) === -1) {
            return false;
        }else{
            return true;
        };
    }
}
//测试
console.log(fn());
</code></pre><hr>
<h1 id="宽容"><a href="#宽容" class="headerlink" title="宽容"></a>宽容</h1><blockquote>
<p>如果你要想成为一个受欢迎的技术人员，“宽容”是第一步： 对需求宽容、对用户宽容、对调用者宽容、对维护者宽容。</p>
<p>——如果 n 是一个字符串数字，是否可以允许进入处理流程？ 如果是，请将经验系数 * 1.1；</p>
<p>——如果 n 是一个含有小数的数字，比如 3.000001，是否允许进入处理流程？如果是，请将经验系数 * 1.1；</p>
<p>——你的代码中，是否有足够多且清晰的注释？ 如果是，请将经验系数 * 1.2；</p>
<p>——如果需求调整了 [2, 32] 的范围，你的代码是否可以快速调整，甚至不用调整？ 如果是，请将经验系数 * 1.2；</p>
</blockquote>
<pre><code>/*获取一个数组，数组内是 n 个随机且不重复的整数，且整数取值范围是 [2, 32]
* @arguments{number} n 需要的整数个数
* @return{array} 如果输入非法，则返回一个空数组
*/
function fn(n){
    //检测n是否存在
    if(n||n===0){

    }else{
        console.log(&apos;请输入参数n&apos;);
        return [];
    };
    //检测n是否为数值且为整数
    if(parseInt(n)!==n){
        console.log(&apos;请输入的n为数值且为整数&apos;);
        return [];
    };
    //检测是n的取值范围
    if(n&lt;1||n&gt;31){
        console.log(&apos;请输入n的取值范围为[1,31]&apos;);
        return [];
    };
    //准备一个容器
    var arr = new Array();
    //提取出数组范围，可根据需求修改
    var min = 2 , max = 32;
    //循环
    for(var i = 0 ; i &lt; n ; i ++){
        //生成随机数
        var num = getRand(min,max);
        //检测是否重复
        if(checkArr(arr,num)){
            i --;
        }else{
            arr.push(num);
        }
    }
    //返回数组
    return arr;

    //所需要自定义的方法

    //生成随机数
    function getRand(min,max){
        var num = Math.floor(Math.random()*(max-min+1)+2);
        return num;
    }

    //检测是否重复
    function checkArr(arr,num){
        if (arr.indexOf(num) === -1) {
            return false;
        }else{
            return true;
        };
    }
}
//测试
console.log(fn());
</code></pre><p>原谅我第一点和第二点做不到，需要学习了正则表达式的相关知识才能处理，留坑。</p>
<hr>
<h1 id="精益求精"><a href="#精益求精" class="headerlink" title="精益求精"></a>精益求精</h1><blockquote>
<p>如果你在实际开发中，时时刻刻留意这些原则，这足够让你的工作经验扩大化，并给你带来更多的认可，这些认可来自于需求方（或许是那个曾经非常蛮横的产品狗）、用户以及你的同事。但不应该包括你自己，你还需要更进一步。</p>
<p>宽容是宽以待人，精益求精是严以律己。内外兼修才是高手。当你将这五个原则（可用、健壮、可靠、宽容、精益求精）变成你自己的开发习惯，你的工作经验就跟你的工作时间没有关系了。</p>
</blockquote>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章很好地提出了实际编程开发中所存在的一些问题，如果能考虑到这些，那么编程实力会有很大的提升。</p>
<p>但是，从另一个角度来说，我觉得实际开发中不会留这么多坑，不是每个程序都要考虑这么多，要根据具体的开发环境而定，一般情况下能做到健壮我觉得就可以了，仅代表个人观点。</p>
<p>而文章最高赞评论也说了这个问题，我觉得说的很有道理。</p>
<blockquote>
<p>孟子易：。。。。要是我面试被要求写代码我肯定只写功能→_→健壮性和可扩展性这种东西我为什么要在面试过程中考虑啊。你这种面试方法就不对，因为在实际过程中我可能会根据这个函数的具体运用来考虑他的输入值是否需要检验，以及哪些地方有可能会被扩展，但是面试中，没有上下文的存在，没有一个环境给我，我完全无法推测哪些地方有可能会被扩展，有可能这是一个完全私有或者说要求严格输入的方法，错误的输入导致的报错则可以迅速定位问题，而扩展更是无从谈起，我咋知道你一定要改最小值和最大值？也许你后期的改动是2-10的几率变成80%呢，所以说，如果我面试别人的时候，别人写了你那种代码，我不会觉得他考虑周全，只会觉得他专门为面试刷了题。脱离环境的任何需求都是耍流氓。</p>
</blockquote>
<p>如果哪里有错误的话请与我联系，我会及时更正，联系方式在右边个人介绍中，谢谢观看。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.klaus1995.com/2017/03/06/JS原型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Klaus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klaus' blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/06/JS原型/" itemprop="url">JS原型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T20:49:59+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/06/JS原型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/06/JS原型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要总结了js面向对象编程的发展过程，参考高程三第六章。</p>
<hr>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>最开始创建一个对象所使用的是工厂模式，因为js没有类的概念，所以通常会封装一个创建对象的函数。</p>
<pre><code>function createPerson(name,age,job){
    var o =new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}

var person1 = createPerson(&apos;Nicholas&apos;,29,&apos;Software Engineer&apos;);
var person2 = createPerson(&apos;Greg&apos;,27,&apos;Doctor&apos;); 
</code></pre><p>工厂模式虽然解决了重复创建固定属性的对象的问题，<strong style="color: red">但是没办法识别创建出的对象的类型</strong>。</p>
<hr>
<h1 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h1><p>js支持创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<pre><code>function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}

var person1 = new Person(&apos;Nicholas&apos;,29,&apos;Software Engineer&apos;);
var person2 = new Person(&apos;Greg&apos;,27,&apos;Doctor&apos;); 
</code></pre><p>其中要创建Person的新实例，必须使用new操作符。用这种方式调用构造函数实际上会经历以下四个步骤：</p>
<ul>
<li>（1）创建一个新对象；</li>
<li>（2）将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li>
<li>（3）执行构造函数中的代码（为这个对象添加属性）；</li>
<li>（4）返回新对象。</li>
</ul>
<p>这种创建对象的方式可以检测对象的类型：</p>
<pre><code>alert(person1 instanceof Object);   //true
alert(person1 instanceof Person);   //true
alert(person2 instanceof Object);   //true
alert(person2 instanceof Person);   //true
</code></pre><p><strong style="color: red">但是这种模式创建的对象，每一个都具有sayName的方法，占用内存，无法实现函数的复用。</strong></p>
<hr>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象。这个对象就是这个构造函数的原型对象，这个对象包含了所有实例所共享的属性和方法。</p>
<pre><code>function Person(){
}

Person.prototype.name = &apos;Nicholas&apos;;
Person.prototype.age = 29;
Person.prototype.job = &apos;Software Engineer&apos;;
Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
person1.sayName();   //&apos;Nicholas&apos;

var person2 = new Person();
person2.sayName();   //&apos;Nicholas&apos;

alert(person1.sayName == person2.sayName);  //true
</code></pre><p>这段代码中，person1和person2都调用了构造函数Person，所以它们有相同的属性和方法。在这里，Person叫做构造函数，Person.prototype叫做原型，person1和person2叫做实例。</p>
<p>可以用isPrototypeOf方法检测实例的原型：</p>
<pre><code>alert(Person.prototype.isPrototypeOf(person1));  //true

alert(Person.prototype.isPrototypeOf(person2));  //true
</code></pre><p>有一种更简便更直观的写法：</p>
<pre><code>function Person(){
}

Person.prototype = {
    name : &apos;Nicholas&apos;,
    age : 29,
    job : &apos;Software Engineer&apos;,
    sayName : function(){
        alert(this.name);
    }
};

Object.defineProperty(Person.prototype,&apos;constructor&apos;,{
    enumerable : false,
    value : Person
})
</code></pre><p><strong style="color: red">需要注意的是，必须指定constructor为Person，不然会指向Object。</strong></p>
<p><strong style="color: red">同时，由于所创建的实例共享了所有属性与方法，这种共享性对方法和共有属性来说是适用的，但对于某些私有属性（尤其是引用类型值的属性）是不适用的，所以原型模式的缺点也显而易见：无法设置实例的私有属性。</strong></p>
<hr>
<h1 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h1><p>这种模式结合了两种模式的优点，代码如下：</p>
<pre><code>function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&apos;shelby&apos;,&apos;court&apos;];
}

Person.prototype = {
    sayName : function(){
        alert(this.name);
    }
};

var person1 = new Person(&apos;Nicholas&apos;,29,&apos;Software Engineer&apos;);
var person2 = new Person(&apos;Greg&apos;,27,&apos;Doctor&apos;); 

person1.friends.push(&apos;Van&apos;);
alert(person1.friends);  //&apos;shelby&apos;,&apos;court&apos;,&apos;Van&apos;
alert(person2.friends);  //&apos;shelby&apos;,&apos;court&apos;
alert(person1.friends == person2.friends);  //false
alert(person1.sayName == person2.sayName);  //true
</code></pre><hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先讲讲new操作符都做了些什么（使用字面量定义对象的时候效果相同）：</p>
<ul>
<li>（1）创建一个新对象；</li>
<li>（2）将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li>
<li>（3）执行构造函数中的代码（为这个对象添加属性）；</li>
<li>（4）返回新对象。</li>
</ul>
<p>这就相当于以下代码：</p>
<pre><code>var person1 = new Object();
function Person(){
    this.name = &apos;Klaus&apos;; 
}

Person.call(person1);

alert(person1.name);  //&apos;Klaus&apos;
</code></pre><p>然后，再说说原型里面的各种指针问题：</p>
<ul>
<li>构造函数Person   </li>
<li>原型Person.prototype   </li>
<li>实例person1</li>
<li>Person.prototype.constructor  ==&gt;  Person</li>
<li>person1的[[prototype]]  ==&gt;  Person.prototype  (由于这个属性是隐藏的不可访问，可以用Person.prototype.isPrototypeOf(person1)为true，或者person1.__proto__  ==&gt;  Person.prototype表示)</li>
<li>由于实例继承了原型的属性，所以person1.constructor  ==&gt;  Person</li>
</ul>
<p><img src="JS原型/JS原型1.png" alt=""></p>
<p>最后，说说最终组合使用构造函数模式和原型模式创建对象的优点：</p>
<ul>
<li>能够检测对象的类型；</li>
<li>能够传递参数，给每个对象设置私有的属性（尤其是引用对象类型的值）；</li>
<li>能够在原型中定义共享的属性和方法，节省了内存。</li>
</ul>
<p>以下代码作为本篇文章的总结，基本可以说明所有问题：</p>
<pre><code>//可以给构造函数传递参数，给每个对象设置私有的属性（尤其是引用对象类型的值）
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&apos;shelby&apos;,&apos;court&apos;];
}

//能够在原型中定义共享的属性和方法，节省了内存
//注意必须指定constructor属性，指向构造函数Person，不然会默认指向构造函数Object
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
};

//创建新实例
var person1 = new Person(&apos;Nicholas&apos;,29,&apos;Software Engineer&apos;);
var person2 = new Person(&apos;Greg&apos;,27,&apos;Doctor&apos;); 

//检测对象的类型
alert(person1 instanceof Person);  //true
alert(person2 instanceof Person);  //true
alert(person1 instanceof Object);  //true
alert(person2 instanceof Object);  //true

//检测原型
alert(Person.prototype.isPrototypeOf(person1));  //true
alert(Person.prototype.isPrototypeOf(person2));  //true

//检测constructor属性
alert(Person.prototype.constructor);  //function Person(){}

//注释掉constructor属性的那行代码后
alert(Person.prototype.constructor);  //function Object(){}

//对实例的私有属性进行操作，不会影响其他实例的属性
person1.friends.push(&apos;Van&apos;);
alert(person1.friends);  //&apos;shelby&apos;,&apos;court&apos;,&apos;Van&apos;
alert(person2.friends);  //&apos;shelby&apos;,&apos;court&apos;

//再次证明了私有属性是每个实例所特有的，而继承原型的属性是共享的
alert(person1.friends == person2.friends);  //false
alert(person1.sayName == person2.sayName);  //true
</code></pre><p>如果哪里有错误的话请与我联系，我会及时更正，联系方式在右边个人介绍中，谢谢观看。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Klaus" />
          <p class="site-author-name" itemprop="name">Klaus</p>
           
              <p class="site-description motion-element" itemprop="description">Keep learning, keep running.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Klaus1995" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/wang-xiao-bai-28-69/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-zhihu"></i>
                  
                  Zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Klaus</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Klaus.disqus.com/count.js" async></script>
    

    

  




	





  








  





  

  

  

  

  

  

</body>
</html>
